import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { access } from 'fs/promises';
import { setTimeout } from 'timers/promises';
import { IsString, validateSync } from 'class-validator';
import { plainToInstance } from 'class-transformer';
import { ScannerServiceError, ScanTimeoutError } from '../scan.errors';
import { VulnerabilityScanner } from './vulnerability-scanner';

class ScannerErrorResponse {
  @IsString()
  error!: string;
}

const POLL_INTERVAL_MS = 5_000;
const SCAN_TIMEOUT_MS = 200_000;

@Injectable()
export class TrivyScanner extends VulnerabilityScanner {
  private readonly logger = new Logger(TrivyScanner.name);
  private readonly scannerBaseUrl: string;

  constructor(configService: ConfigService) {
    super();
    this.scannerBaseUrl = configService.getOrThrow<string>('SCANNER_URL');
  }

  async scan(scanId: string, repositoryPath: string): Promise<string> {
    const reportPath = `/tmp/${scanId}.json`;

    this.logger.log(
      `Running Trivy scan on ${repositoryPath}, report: ${reportPath}`
    );

    await this.requestScan(repositoryPath, reportPath);
    await this.waitForReport(reportPath);

    return reportPath;
  }

  private async requestScan(
    repositoryPath: string,
    reportPath: string
  ): Promise<void> {
    const response = await fetch(`${this.scannerBaseUrl}/scan`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ repositoryPath, reportPath }),
    });

    if (!response.ok) {
      let message = `Scanner responded with ${response.status}`;
      try {
        const body = plainToInstance(
          ScannerErrorResponse,
          await response.json()
        );
        const errors = validateSync(body, { forbidNonWhitelisted: false });
        if (errors.length === 0) {
          message = body.error;
        }
      } catch {
        /* response is not JSON */
      }
      throw new ScannerServiceError(message);
    }
  }

  private async waitForReport(reportPath: string): Promise<void> {
    const deadline = Date.now() + SCAN_TIMEOUT_MS;

    while (Date.now() < deadline) {
      try {
        await access(reportPath);
        return;
      } catch {
        await setTimeout(POLL_INTERVAL_MS);
      }
    }

    throw new ScanTimeoutError(reportPath, SCAN_TIMEOUT_MS);
  }
}
